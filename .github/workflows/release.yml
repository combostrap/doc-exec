name: Release
# Ref: https://raw.githubusercontent.com/jreleaser/helloworld-java-jpackage/refs/heads/main/.github/workflows/release.yml

on:
  # Trigger on button click
  workflow_dispatch:
  # Trigger on tag push
  push:
    tags:
      - 'v*'

# Release Token
# https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/scopes-for-oauth-apps#available-scopes
# The release token should have:
#   * repo scope to create a repo (at least public_repo) to create and manage public repositories
#   * workflow to create workflow files
#   * packages to write packages

# GITHUB_TOKEN: Token permission
# https://docs.github.com/en/actions/reference/workflows-and-actions/workflow-syntax#permissions
# We publish to other repo in the same organisation
# permissions control what the GITHUB_TOKEN can do within the repository where the workflow is running.
permissions:
  packages: write # Allow creating package in the same repo
  contents: write # Allow creating a GitHub release in the same repo

# Constant for entire workflow
env:
  JRELEASER_JPACKAGE_ASSEMBLY_NAME: 'doc-exec-installer' # The jpackage assembly name
  JRELEASER_JLINK_ASSEMBLY_NAME: 'doc-exec-jre' # The jlink assembly name
  JRELEASER_JAVA_ARCHIVE_ASSEMBLY_NAME: 'doc-exec-nojre'
  JRELEASER_OUT_DIRECTORY: 'target'
  WORKFLOW_ID: release # the workflow name without extension

jobs:


  # Assemble Installers
  assemble-jpackage:
    uses: ./.github/workflows/release-assemble-jpackage.yml
    with:
      os: 'windows-latest'

  # Assemble artifacts except installers
  # Release all generated artifacts
  release:
    runs-on: ubuntu-latest
    needs: [ assemble-jpackage ]
    environment: release
    if: always() # run even if we don't require the assembly
    steps:

      # Checkout first as we do a control on the pom.xml version
      - name: Git Checkout ${{ github.ref_name }}
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      # Homebrew is installed but not in the path
      # https://github.com/actions/runner-images/issues/6283
      - name: Homebrew Setup
        run: echo "/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin" >> $GITHUB_PATH
      - name: Homebrew Utility Installation
        run: brew install yq

      # Extract Props from pom.xml
      - name: Props And Version Check ${{ github.ref_name }}
        id: props
        shell: bash
        run: |
          
          set -TCEeuo pipefail
          
          # Ref
          REF=${{ github.ref_name }}
          echo "ref=${REF}" >> $GITHUB_OUTPUT
          
          # Generate the effective pom
          POM_EFFECTIVE="${{runner.temp}}/pom-effective.xml"
          ./mvnw help:effective-pom --quiet "-Doutput=$POM_EFFECTIVE"
          
          # Project version and check
          PROJECT_VERSION=$(yq --exit-status '.project.version' "$POM_EFFECTIVE")
          echo "project_version=$PROJECT_VERSION" >> $GITHUB_OUTPUT
          
          if [ "v$PROJECT_VERSION" != "$REF" ]; then
            echo "Project version in pom.xml (v$PROJECT_VERSION) is not the same as the branch/tag $REF"
            exit 1
          fi
          
          JDK_VERSION=$(yq --exit-status '.project.properties."jdk.version"' "$POM_EFFECTIVE")
          echo "jdk_version=$JDK_VERSION" >> $GITHUB_OUTPUT

          JDK_DISTRO=$(yq --exit-status '.project.properties."jdk.distribution"' "$POM_EFFECTIVE")
          echo "jdk_distro=$JDK_DISTRO" >> $GITHUB_OUTPUT

          JDK_DOWNLOAD_DIRECTORY=$(yq --exit-status '.project.properties."jdk.download-directory"' "$POM_EFFECTIVE")
          echo "jdk_download_directory=$JDK_DOWNLOAD_DIRECTORY" >> $GITHUB_OUTPUT

          # JDK Name - The jdk and runner id
          # The name uses to download the jdk. It's unique by runner and unique by jdk
          # It should be lowercase, we use the bash syntax to do that
          # Why Node and not bash subsitution, macOS has an old bash: 3.2.57(1)-release
          JDK_NAME=$(echo 'console.log("${{ runner.os }}-${{ runner.arch }}".toLowerCase())' | node -);
          echo "jdk_name=${JDK_NAME}" >> $GITHUB_OUTPUT


      # Cache to not download the maven dependency between matrix run
      # https://github.com/actions/cache/blob/main/examples.md#java---maven
      - name: Cache local Maven repository
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-          

      - name: Setup Java
        uses: actions/setup-java@v5
        with:
          java-version: ${{ steps.props.outputs.jdk_version }}
          distribution: ${{ steps.props.outputs.jdk_distro }}
          cache: maven

      # Run the jdks profile default goal with maven wrapper
      - name: Maven Setup JDKs
        # The shell is bash on Linux and Powershell in Windows
        run: ./mvnw --no-transfer-progress --batch-mode --file pom.xml -Pjdks

      # Run the deps profile default goal with maven wrapper
      # Jlink packaging needs them
      - name: Maven Copy dependencies
        run: ./mvnw --no-transfer-progress --batch-mode --quiet --file pom.xml -Pdeps

      # Build jar
      - name: Maven Build
        run: ./mvnw --no-transfer-progress --batch-mode --file pom.xml -DskipTests package

      # Create Java Archive
      - name: Java Archive Assemble
        uses: jreleaser/release-action@v2
        with:
          arguments: assemble --assembler java-archive
          setup-java: false
        env:
          JRELEASER_PROJECT_VERSION: ${{ steps.props.outputs.project_version }}
          JRELEASER_OUTPUT_DIRECTORY: ${{ env.JRELEASER_OUT_DIRECTORY }}

      # Jlink and Jpackage assembly
      - name: Jlink Archive Assemble
        uses: jreleaser/release-action@v2
        with:
          arguments: assemble --assembler jlink
          setup-java: false
        env:
          JRELEASER_PROJECT_VERSION: ${{ steps.props.outputs.project_version }}
          JRELEASER_OUTPUT_DIRECTORY: ${{ env.JRELEASER_OUT_DIRECTORY }}
          JDK_DOWNLOAD_DIRECTORY: ${{ steps.props.outputs.jdk_download_directory }}
          JDK_VERSION: ${{ steps.props.outputs.jdk_version }}
          JDK_DISTRO: ${{ steps.props.outputs.jdk_distro }}

      # Download Installer created by the jpackage assemble workflow
      - name: Download Jpackage Installer Artifacts
        uses: actions/download-artifact@v4
        continue-on-error: false
        with:
          pattern: jpackage-*
          merge-multiple: true # download them to the same directory
          path: ${{env.JRELEASER_OUT_DIRECTORY}}/jreleaser/assemble/${{env.JRELEASER_JPACKAGE_ASSEMBLY_NAME}}/jpackage

      - name: Display structure of downloaded files
        run: ls -R

      - name: Import Gpg Signing Key
        shell: bash
        run:
          gpg --batch --yes --passphrase "${{ secrets.GPG_SOFTWARE_SIGNING_PASSPHRASE }}" --import <(echo "${{ secrets.GPG_SOFTWARE_SIGNING_KEY }}")

      - name: Release
        uses: jreleaser/release-action@v2
        with:
          arguments: full-release
        env:
          JRELEASER_GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}
          JRELEASER_DOCKER_GHCR_IO_PASSWORD: ${{ secrets.RELEASE_TOKEN }}
          JRELEASER_PROJECT_VERSION: ${{ steps.props.outputs.project_version }}
          JRELEASER_GPG_PASSPHRASE: ${{ secrets.GPG_SOFTWARE_SIGNING_PASSPHRASE }}
          JRELEASER_OUTPUT_DIRECTORY: ${{ env.JRELEASER_OUT_DIRECTORY }}

      - name: JReleaser Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          retention-days: 1
          name: jreleaser-logs-${{env.WORKFLOW_ID}}
          path: |
            ${{env.JRELEASER_OUT_DIRECTORY}}/jreleaser/trace.log
            ${{env.JRELEASER_OUT_DIRECTORY}}/jreleaser/output.properties
